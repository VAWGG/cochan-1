import test from './helpers'
import chan from '../src'

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#canTakeSync is false when non-buffered chan has no outstanding sends`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#canTakeSync is false when buffered chan has no buffered values`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(1)
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#canTakeSync is true when there is an outstanding send on a non-buffered chan, and changes ` +
     `to false when this send gets propagated`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  ch.send('x')
  await t.nextTick()
  t.ok(ch.canTakeSync == true)
  await ch.take()
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#canTakeSync is true when there is an outstanding send on a non-buffered chan, and changes ` +
     `to false when this send gets propagated (error case)`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  ch.sendError(new Error(`oops`))
  await t.nextTick()
  t.ok(ch.canTakeSync == true)
  await ch.take().then(t.fail, t.nop)
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#canTakeSync is true when there is a value buffered in a chan, and changes to false when ` +
     `this value gets consumed`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(1)
  await ch.send('x')
  t.ok(ch.canTakeSync == true)
  await ch.take()
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#canTakeSync is true when there is a value buffered in a chan, and changes to false when ` +
     `this value gets consumed (error case)`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(1)
  await ch.sendError(new Error(`oops`))
  t.ok(ch.canTakeSync == true)
  await ch.take().then(t.fail, t.nop)
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() consumes value from a waiting send and returns true`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  let sent = ch.send('x')
  await t.nextTick()
  t.ok(ch.takeSync() == true)
  t.ok(ch.value == 'x')
  t.ok(ch.canTakeSync == false)
  await sent
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() throws error from a waiting send`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  let sent = ch.sendError(new Error('oops'))
  await t.nextTick()
  t.throws(() => ch.takeSync(), /oops/)
  t.ok(ch.value === undefined)
  t.ok(ch.canTakeSync == false)
  await sent
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() consumes buffered value from a channel and returns true`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(1)
  await ch.send('x')
  t.ok(ch.takeSync() == true)
  t.ok(ch.value == 'x')
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() throws buffered error`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(1)
  await ch.sendError(new Error('oops'))
  t.throws(() => ch.takeSync(), /oops/)
  t.ok(ch.value === undefined)
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() returns false when called on a closed channel`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  ch.closeNow()
  t.ok(ch.takeSync() == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() returns false and doesn't perform the take when it cannot do that synchronously`,
////////////////////////////////////////////////////////////////////////////////////////////////////
async t => {
  let ch1 = chan(0)

  t.ok(ch1.takeSync() == false)
  let pTaken1 = ch1.take()
  await t.nextTick()
  t.ok(ch1.takeSync() == false)
  await ch1.send('b')
  t.is('b', await pTaken1)

  let ch2 = chan(1)

  t.ok(ch2.takeSync() == false)
  let pTaken2 = ch2.take()
  await t.nextTick()
  t.ok(ch2.takeSync() == false)
  await ch2.send('r')
  t.is('r', await pTaken2)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\//
////////////////////////////////////////////////////////////////////////////////////////////////////

function consumeSync(ch, t, { max }) {
  let recv = ''
  let i = 0
  while (true) {
    let value
    try {
      if (!ch.takeSync()) {
        return recv
      }
      recv += ch.value
    } catch (err) {
      recv += `(${ err.message })`
    }
    if (++i > max) {
      return t.fail(`consumed more values (${i}) than expected (${max}): ${recv}`)
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() can be called in a loop to consume values from all waiting sends`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  let sent = Promise.all([
    ch.send('x'),
    ch.sendError(new Error('y')),
    ch.send('z')
  ])
  await t.nextTick()
  let recv = consumeSync(ch, t, { max: 3 })
  t.ok(recv == 'x(y)z')
  await sent
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() can be called in a loop to consume all buffered values`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(2)
  await ch.sendError(new Error('a'))
  await ch.send('b')
  let recv = consumeSync(ch, t, { max: 2 })
  t.ok(recv == '(a)b')
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() can be called in a loop to consume all buffered values, and then all values ` +
     `from outstanding sends`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(2)
  ch.send('a')
  ch.sendError(new Error('b'))
  let sent = Promise.all([
    ch.sendError(new Error('c')),
    ch.send('d')
  ])
  await t.nextTick()
  let recv = consumeSync(ch, t, { max: 4 })
  t.ok(recv == 'a(b)(c)d')
  await sent
})
