import test from './helpers'
import chan from '../src'

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#canTakeSync is false when non-buffered chan has no outstanding sends`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#canTakeSync is false when buffered chan has no buffered values`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(1)
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#canTakeSync is true when there is an outstanding send on a non-buffered chan, and changes ` +
     `to false when this send gets propagated`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  ch.send('x')
  await t.nextTick()
  t.ok(ch.canTakeSync == true)
  await ch.take()
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#canTakeSync is true when there is a value buffered in a chan, and changes to false when ` +
     `this value gets consumed`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(1)
  await ch.send('x')
  t.ok(ch.canTakeSync == true)
  await ch.take()
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() consumes value from a waiting send and returns true`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  let sent = ch.send('x')
  await t.nextTick()
  t.ok(ch.takeSync() == true)
  t.ok(ch.value == 'x')
  t.ok(ch.canTakeSync == false)
  await sent
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() consumes buffered value from a channel and returns true`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(1)
  await ch.send('x')
  t.ok(ch.takeSync() == true)
  t.ok(ch.value == 'x')
  t.ok(ch.canTakeSync == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() returns false when called on a closed channel`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  ch.closeNow()
  t.ok(ch.takeSync() == false)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() returns false and doesn't perform the take when it cannot do it synchronously`,
////////////////////////////////////////////////////////////////////////////////////////////////////
async t => {
  let ch1 = chan(0)

  t.ok(ch1.takeSync() == false)
  let pTaken1 = ch1.take()
  await t.nextTick()
  t.ok(ch1.takeSync() == false)
  await ch1.send('b')
  t.is('b', await pTaken1)

  let ch2 = chan(1)

  t.ok(ch2.takeSync() == false)
  let pTaken2 = ch2.take()
  await t.nextTick()
  t.ok(ch2.takeSync() == false)
  await ch2.send('r')
  t.is('r', await pTaken2)
})

////////////////////////////////////////////////////////////////////////////////////////////////////
//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\//
////////////////////////////////////////////////////////////////////////////////////////////////////

function consumeSync(ch, t, { max }) {
  let recv = ''
  let i = 0
  while (ch.takeSync()) {
    if (++i > max) {
      return t.fail(`consumed more values (${i}: ${recv}) than expected (${max}), last: ${ch.value}`)
    }
    recv += ch.value
  }
  return recv
}

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() can be called in a loop to consume values from all waiting sends`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan()
  let sent = Promise.all([
    ch.send('x'),
    ch.send('y'),
    ch.send('z')
  ])
  await t.nextTick()
  let recv = consumeSync(ch, t, { max: 3 })
  t.ok(recv == 'xyz')
  await sent
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() can be called in a loop to consume all buffered values`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(2)
  await ch.send('a')
  await ch.send('b')
  let recv = consumeSync(ch, t, { max: 2 })
  t.ok(recv == 'ab')
})

////////////////////////////////////////////////////////////////////////////////////////////////////
test(`#takeSync() can be called in a loop to consume all buffered values, and then all values ` +
     `from outstanding sends`, async t => {
////////////////////////////////////////////////////////////////////////////////////////////////////
  let ch = chan(2)
  ch.send('a')
  ch.send('b')
  let sent = Promise.all([
    ch.send('c'),
    ch.send('d')
  ])
  await t.nextTick()
  let recv = consumeSync(ch, t, { max: 4 })
  t.ok(recv == 'abcd')
  await sent
})
